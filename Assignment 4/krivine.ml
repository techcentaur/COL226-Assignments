(* expressions for the language *)
type exp = Nil | Int of int | Bool of bool | Var of string | Abs of string * exp | App of exp * exp | Absolute of exp| Not of exp
	| Add of exp*exp| Sub of exp*exp| Div of exp*exp| Mul of exp*exp| Mod of exp*exp| Exp of exp*exp
	| And of exp*exp| Or of exp*exp| Imp of exp*exp
	| Equ of exp*exp| GTEqu of exp*exp| LTEqu of exp*exp| Grt of exp*exp| Lst of exp*exp
	| Ifthenelse of (exp*exp*exp);;


(* opcode list generated by compiler, if used *)
type opcode =  NIL | INT of int | BOOL of bool | LOOKUP of string | CLOS of string*(opcode list) | CALL | RET | ADD;;


(* inter-dependent types *)
type table = (string * answer) list 
	and answer = I of int | B of bool | Vclos of table*string*control
		and stack = answer list
			and environment = table
				and control = opcode list
					and dump = stack*environment*control
						and program = exp list
							and stackCLOS = closure list
								and closure = CLtype of exp*environmentCLOS
									and environmentCLOS = (exp*closure) list;;


(* Exceptions *)
exception Variable_not_intialized;;
exception InvalidOperation;;
exception OperationNotSupported;;
exception InvalidBigStepAnswerClosure;;
exception ReturnEmpty;;



(* functions used in inter-computation *)

let rec lookup (e, env) = match (e, env) with
	| (e, (e1,cl)::c') -> if e1<>e then lookup (e, c') else
					(match cl with
					| CLtype (Abs (x,x1), env) -> CLtype (Abs (x, x1), (e1,cl)::env)
					| _ -> cl)
	| (e, []) -> raise Variable_not_intialized;;

let rec power a b = match (a,b) with
	(a,0) -> 1 |
	(a,b) -> a*(power a (b-1));;

let imp a b = match(a,b) with (true,false) -> false | _-> true;;



(* val absApplied : closure * closure list -> closure * closure list = <fun> *)
let absApplied (cl, s) = match (cl, s) with
	| (CLtype(Abs(x ,e), env), c::c') -> (CLtype(e, (Var x, c)::env), c')
	| (_,[]) -> raise InvalidOperation
	| _ -> raise InvalidOperation;;


(* functions defined as :  closure * closure -> closure = <fun> *)
let add (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Int (i1+i2), [])
	| _-> raise InvalidOperation;;

let mul (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Int (i1*i2), [])
	| _-> raise InvalidOperation;;

let sub (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Int (i1-i2), [])
	| _-> raise InvalidOperation;;

let div (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Int (i1/i2), [])
	| _-> raise InvalidOperation;;

let exponential (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Int (power i1 i2), [])
	| _-> raise InvalidOperation;;

let modulus (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Int (i1 mod i2), [])
	| _-> raise InvalidOperation;;

let absolute (a1) = match (a1) with
	(CLtype(Int i1, env1)) -> CLtype(Int (if i1>0 then i1 else ((-1)*i1)), [])
	| _-> raise InvalidOperation;;

let andop (a1, a2) = match (a1,a2) with
	(CLtype(Bool i1, env1), CLtype(Bool i2, env2)) -> CLtype(Bool (i1 && i2), [])
	| _-> raise InvalidOperation;;

let orop (a1, a2) = match (a1,a2) with
	(CLtype(Bool i1, env1), CLtype(Bool i2, env2)) -> CLtype(Bool (i1 || i2), [])
	| _-> raise InvalidOperation;;

let imp (a1, a2) = match (a1,a2) with
	(CLtype(Bool i1, env1), CLtype(Bool i2, env2)) -> CLtype(Bool (imp i1 i2), [])
	| _-> raise InvalidOperation;;

let notop (a1) = match (a1) with
	(CLtype(Bool i1, env1)) -> CLtype(Bool (not i1), [])
	| _-> raise InvalidOperation;;

let equal (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Bool (if i1==i2 then true else false), [])
	| _-> raise InvalidOperation;;

let greaterthanorequal (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Bool (if i1>=i2 then true else false), [])
	| _-> raise InvalidOperation;;

let lessthanorequal (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Bool (if i1<=i2 then true else false), [])
	| _-> raise InvalidOperation;;

let greaterthan (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Bool (if i1>i2 then true else false), [])
	| _-> raise InvalidOperation;;

let lessthan (a1, a2) = match (a1,a2) with
	(CLtype(Int i1, env1), CLtype(Int i2, env2)) -> CLtype(Bool (if i1<i2 then true else false), [])
	| _-> raise InvalidOperation;;



(* Krivine machine evaluation with expression *)

let rec krivinemachine cl (s:stackCLOS) = match cl with
	| CLtype (Nil, env) -> CLtype (Nil, env)
	| CLtype (Int i, env) -> CLtype (Int i, env)
	| CLtype (Bool b, env) -> CLtype (Bool b, env)
	| CLtype (Var v, env) -> krivinemachine (lookup (Var(v), env)) s
	| CLtype (Abs(x, e), env) -> 
					let (cl', s') = absApplied (cl, s) in
						krivinemachine cl' s'
	| CLtype (App(e1, e2), env) -> krivinemachine (CLtype(e1, env)) (CLtype(e2, env)::s)
	| CLtype (Add(e1, e2), env) -> (krivinemachine (add ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Sub(e1, e2), env) -> (krivinemachine (sub ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Mul(e1, e2), env) -> (krivinemachine (mul ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Div(e1, e2), env) -> (krivinemachine (div ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Exp(e1, e2), env) -> (krivinemachine (exponential ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Mod(e1, e2), env) -> (krivinemachine (modulus ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Absolute(e1), env) -> (krivinemachine (absolute ((krivinemachine (CLtype(e1, env)) []))) s)
	| CLtype (And(e1, e2), env) -> (krivinemachine (andop ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Or(e1, e2), env) -> (krivinemachine (orop ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Imp(e1, e2), env) -> (krivinemachine (imp ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Not(e1), env) -> (krivinemachine (notop ( (krivinemachine (CLtype(e1, env)) []))) s)
	| CLtype (Equ(e1, e2), env) -> (krivinemachine (equal ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (GTEqu(e1, e2), env) -> (krivinemachine (greaterthanorequal ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (LTEqu(e1, e2), env) -> (krivinemachine (lessthanorequal ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Grt(e1, e2), env) -> (krivinemachine (greaterthan ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Lst(e1, e2), env) -> (krivinemachine (lessthan ((krivinemachine (CLtype(e1, env)) []), (krivinemachine (CLtype(e2, env)) []))) s)
	| CLtype (Ifthenelse(e0, e1, e2), env) ->
				let a0 = (krivinemachine (CLtype(e0, env)) []) in
					(match a0 with
					| CLtype(Bool b, env) -> (if b then (krivinemachine (CLtype(e1, env)) s) else (krivinemachine (CLtype(e1, env)) s))
					| _ -> raise InvalidOperation)
					;;



(* Execution of krivine function *)

let rec executekrivine (prog: program) (env: environmentCLOS): answer = match prog with
	| p::prog' -> 
				let cl = krivinemachine (CLtype(p, env)) [] in 
					(match cl with
						| CLtype (Nil, env') -> executekrivine prog' env'
						| CLtype (Int i, _) -> I i
						| CLtype (Bool b, _) -> B b
						| _-> raise InvalidBigStepAnswerClosure
					)
	| _-> raise ReturnEmpty;;

(* 
let p = App(Abs("x", Add(Var "x", Int 7)), Int 3);; 

let pp = App(Abs("x", Add(Var "x", (Sub(Int 10, Var "x")))), Int 3);; 

let ppp = App(Abs("x", Add(Var "x", (Sub(Ifthenelse(Bool true, Int 10, Int 15), Var "x")))), Int 3);; 

let newp = [p];;
executekrivine newp [];;

let newp = [pp];;
executekrivine newp [];;

let newp = [ppp];;
executekrivine newp [];; *)
